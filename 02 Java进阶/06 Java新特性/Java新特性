## Java 10新特性

不知不觉，Java 11都将很快与我们见面了，Java 10也已经发布快半年了，而我们很多人还停留在Java 7、6。。。，不得不说，Java的迭代速度太快了，新周期是每半年一个版本。

## Java 10新特性
Java 10 是采用新发布周期的第一个版本，提供了 109 项新特性，其中最备受关注的莫过于局部变量的类型推断。

var list = new ArrayList<String>();  // infers ArrayList<String>
var stream = list.stream();          // infers Stream<String>

这样的 Java 代码你喜欢吗？

### Java 10 的 12 项关键新特性：
#### JEP 286: 局部变量的类型推断。
局部变量类型推断是Java 10中最显着的特性。在进入JDK 10之前，争论非常激烈，该特性允许编译器推断局部变量的类型，而不是要求程序员明确指定它。

如下 显示了如何在Java 10之前定义一个String变量类型。
String name = "zhangsan";
声明并分配一个String类型的变量

如下展示了在Java10中定义与String类型相同的变量
var name = "zhangsan";
用局部变量类型推断String类型的变量

正如你看到的，唯一的区别就是使用了var保留类型名称。使用右边的表达式，编译器可以将变量名的类型推断为String

这看起来有点简单，让我们来看一个更加复杂的例子。如果一个变量分配给了调用方法的返回值是怎样的？在这种情况下，编译器可以根据方法的返回类型推断变量的类型。

如下.从返回类型推断String类型
var name = getName();
String getName(){
    return "zhangsan";
}
使用局部变量类型

顾名思义，局部变量类型推断功能仅适用于局部变量。 它不能用于定义实例或类变量，也不能用于方法参数或返回类型。 但是，您可以在类和增强型循环中使用var，可以从迭代器中推断出类型，如清单4所示。

如下.在循环中使用var
for(var book : books){}
for(int i = 0 ; i < 10 ; i++){}

使用这种类型的最明显的原因是为了减少代码中的冗长。


局部变量类型的问题

1. var掩盖了类型

你已经看到了var如何提高代码的可读性，但是从另一方面来看，它也可以掩盖它。 看看下面的示例，我们必须猜测返回类型。 让读码者猜测发生了什么的代码是难以维护的。
var result = searchService.getAfsService();

2. var不能与lambda一起使用

与lambda表达式一起使用时，类型推断效果不佳，主要原因是编译器缺少类型信息。 如下示例中的lambda表达式不会被编译。如下示例中类型信息不足
Function<String,String> quotify = m -> "'"+message+"'";
var quotify = m -> "'" + message + "'";
在上面示例中，编译器的右边表达式中没有足够的类型信息来推断变量类型。 Lambda语句必须始终声明一个显式类型。

3. var不会与菱形操作符混在一起

与菱形操作符一起使用时，类型推断也不能很好地工作。 如下示例使用带有var的菱形运算符
var books = new ArrayList<>();

books的ArrayList的参数类型是什么呢？你可能明白你是希望ArrayList存储一个书的列表，但是编译器不能推断出来。反之，编译器会做的唯一它能做的事情，就是推断出来这是一个参数是Object类型ArrayList：ArrayList<Object>()。

另外一种方法就是在右端表达式中的菱形运算符中定义具体类型。然后你可以让编译器从而推断出来变量的类型，就像如下示例中写的一样。或者使用另外一种方式，即你必须明确地以传统方式声明变量：List<Book> books。事实上，你可能更喜欢这种方式，因为它能让你定义一个抽象类型，并对List接口编程：

如下， 定义出具体类型
var books = new ArrayList<Book>();

####JEP 296: 将 JDK 的多个代码仓库合并到一个储存库中
为了简化开发流程，将jdk的数个代码仓库汇集到一个代码仓库中.
多年来，JDK的完整代码库已被分解成多个代码仓库。在JDK 9中有八个仓库：root，corba，hotspot，jaxp，jaxws，jdk，langtools和nashorn。
虽然这种多仓库模式提供了一些优点，但它也有许多缺点，并且在源代码管理操作方面做得不好。特别是，不可能跨越相互依赖的变更集的仓库执行原子提交。
为了解决上面这些问题，已经开发了一个综合仓库的原型。原型可在：

    仓库： http://hg.openjdk.java.net/jdk10/consol-proto/

一些用于创建原型的支持转换脚本附加为unify.zip。

在原型仓库中，八个存储库已经使用自动转换脚本合并到一个仓库中，该脚本在每个文件级别上保留了历史记录，并且在用于标记JDK的一些变更。变更集注释和创建日期也被保留。

原型有另一个代码重组的水平。在合并后的仓库中，Java模块的代码通常组合在单个顶级src目录下。例如，今天在JDK综合仓库中就有基于模块的目录

$ROOT/jdk/src/java.base
...
$ROOT/langtools/src/java.compiler
...

在综合仓库中，代码组织形式如下：

$ROOT/src/java.base
$ROOT/src/java.compiler
...

因此，在代码仓库的根目录中，合并和src目录组合之后，将保留模块中源文件的相对路径。

测试目录组织形式发生如下变更：

从

$ROOT/jdk/test/Foo.java
$ROOT/langtools/test/Bar.java

转为

$ROOT/test/jdk/Foo.java
$ROOT/test/langtools/Bar.java

由于目前在做的仅仅是一个原型，并不是所有部分都完全完成，并且在一些地方需要调整兼容性和适当性。 HotSpot C / C ++源代码与模块化Java代码一起被移至共享src目录。

回归测试将与原型的当前状态一起运行，但jtreg配置文件的进一步整合是可能的，并且可能在将来完成。

####JEP 304: 垃圾收集器接口。通过引入一个干净的垃圾收集器（GC）接口，改善不同垃圾收集器的源码隔离性。
在当前的JDK结构中，组成垃圾收集器(GC)实现的组件分散在代码库的各个部分。尽管这些惯例对于使用GC计划的JDK开发者比较熟悉，但对新的开发人员来说，对于特定GC的源代码，或者创建一个新的GC常常会感到困惑。更重要的是，随着Java modules的出现，我们希望在构建过程中排除不需要的GC，但是GC接口的当前横切结构排除了这种增强。

JEP 304被设计为解决此问题的方案，并建议整合并清理GC接口，以便更容易地实现新的GC，并更好地维护现有的GC。本建议完成后，GC执行将负责提供以下内容:

    heap，CollectedHeap的子类

    barrier set，BarrierSet的子类，它实现了运行时的各种障碍

    一个CollectorPolicy的实现

    GCInterpreterSupport的实现，它实现了解释器的GC的各种障碍(使用汇编指令)

    GCC1Support的实现，它为C1编译器实现了GC的各种障碍

    GCC2Support的实现，它为C2编译器实现了GC的各种障碍

    最终GC特定参数的初始化

    设置MemoryService、相关的内存池、内存管理器等。

有关这些更改的更多信息，请参见JEP 304规范;有关Java GC的更多信息，请参阅Oracle提供的垃圾收集器基础指南。

####JEP 307: 向 G1 引入并行 Full GC
随着JDK 9的发布，Garbage-First(G1)GC取代了Parallel Collector作为默认GC。为了减少JDK 9之外的JDK版本中垃圾收集的影响，G1收集器将被并行化(以匹配并行收集器的特征)。虽然目前还没有关于这个并行化的实现细节的信息，但是可以在JEP 307规范中找到关于此更改的更多细节。

有关GC实现的更多信息，请参阅Oracle的G1指南和并行收集器指南。

####JEP 310: 应用类数据共享。为改善启动和占用空间，在现有的类数据共享（“CDS”）功能上再次拓展，以允许应用类放置在共享存档中
此特性的用途是提高运行间和多个运行相同代码的JVM启动时间，同时减少内存占用量。 这通过在JVM之间共享关于类的元数据来实现。 JVM的第一次运行收集并归档有关它所加载的类的数据。 然后它将数据文件提供给其他JVM以及该JVM的后续运行，从而节省JVM初始化过程中的时间和资源。 类数据共享实际上已经有一段时间了，但仅限于系统类。 现在这个功能已经扩展到包含所有的应用程序类。

####JEP 312: 线程局部管控。允许停止单个线程，而不是只能启用或停止所有线程
这是在 JVM 内部相当低级别的更改，现在将允许在不运行全局虚拟机安全点的情况下实现线程回调。这将使得停止单个线程变得可能和便宜，而不是只能启用或停止所有线程。

####JEP 313: 移除 Native-Header Generation Tool (javah)
Java9 开始了一些对 JDK 的家务管理，这项特性是对它的延续。当编译 JNI 代码时，已不再需要单独的工具来生成头文件，因为这可以通过 javac 完成。在未来的某一时刻，JNI 将会被 Panama 项目的结果取代，但是何时发生还不清楚。 

####JEP 314: 额外的 Unicode 语言标签扩展。包括：cu (货币类型)、fw (每周第一天为星期几)、rg (区域覆盖)、tz (时区) 等
增强 java.util.Locale 和相关 API，实现 BCP 47 语言标签中额外的 Unicode 扩展，支持BCP 47语言标记在 Java SE 7 中最初被添加的，支持Unicode区域设置扩展限于日历和数字。这个JEP将在相关的JDK类中实现最新 LDML 规范中指定的扩展。尤其是，货币类型，一周的第一天，区域覆盖和时区等标签现在将被支持。

####JEP 316: 在备用内存设备上分配堆内存。允许 HotSpot 虚拟机在备用内存设备上分配 Java 对象堆
硬件技术在持续进化，现在可以使用与传统 DRAM 具有相同接口和类似性能特点的非易失性 RAM 。这项 JEP 将使得 JVM 能够使用适用于不同类型的存储机制的堆。

####JEP 317: 基于 Java 的 JIT 编译器（试验版本）
最近宣布的 Metropolis 项目，提议用 Java 重写大部分 JVM 。乍一想，觉得很奇怪。如果 JVM 是用 Java 编写的，那么是否需要一个 JVM 来运行 JVM ？ 相应的，这导致了一个很好的镜像类比。 现实情况是，使用 Java 编写 JVM 并不意味着必须将其编译为字节码，你可以使用 AOT 编译，然后在运行时编译代码以提高性能。

####JEP 319: 根证书。开源 Java SE Root CA 程序中的根证书
在 JDK 中将提供一套默认的 CA 根证书。关键的安全部件，如 TLS ，在 OpenJDK 构建中将默认有效。这是 Oracle 正在努力确保 OpenJDK 二进制和 Oracle JDK 二进制功能上一样的工作的一部分，是一项有用的补充内容。

####JEP 322: 基于时间的版本发布模式。“Feature releases” 版本将包含新特性，“Update releases” 版本仅修复 Bug
我们的 JDK 版本字符串格式几乎与 JDK 版本一样多。幸运的是，这是最后需要使用到的，我们可以坚持用它。这种格式使用起来很像 JDK9 中介绍的提供一个更加语义的形式。有一件困扰我的事是包含了一个 INTERIM 元素，正如 JEP 提议中所说，“永远是0”。好吧，如果永远是0，那它有什么意义呢？他们说这是为未来使用做保留，但我仍不是很赞同。我认为，这有些冗余繁杂。
　　这也消除了在 JDK9 中有过的相当奇怪的情形。第一次更新是 JDK 9.0.1 , 非常符合逻辑。第二次更新是 JDK 9.0.4 ，不合逻辑。原因是，在 JDK9 的版本计数模式下，需要留下空白以便应急或不在预期安排的更新使用。但既然没有更新是必须的，为什么不简单称之为 JDK 9.0.2 呢？
　　
