# Java 10新特性

不知不觉，Java 11都将很快与我们见面了，Java 10也已经发布快半年了，而我们很多人还停留在Java 7、6。。。，不得不说，Java的迭代速度太快了，新周期是每半年一个版本。

## Java 10新特性
Java 10 是采用新发布周期的第一个版本，提供了 109 项新特性，其中最备受关注的莫过于局部变量的类型推断。

var list = new ArrayList<String>();  // infers ArrayList<String>
var stream = list.stream();          // infers Stream<String>

这样的 Java 代码你感觉如何？

### Java 10 的 12 项关键新特性：
#### JEP 286: 局部变量的类型推断。
局部变量类型推断是Java 10中最显着的特性。在进入JDK 10之前，争论非常激烈，该特性允许编译器推断局部变量的类型，而不是要求程序员明确指定它。

如下 显示了如何在Java 10之前定义一个String变量类型。
String name = "zhangsan";
声明并分配一个String类型的变量

如下展示了在Java10中定义与String类型相同的变量
var name = "zhangsan";
用局部变量类型推断String类型的变量

正如你看到的，唯一的区别就是使用了var保留类型名称。使用右边的表达式，编译器可以将变量名的类型推断为String

这看起来有点简单，让我们来看一个更加复杂的例子。如果一个变量分配给了调用方法的返回值是怎样的？在这种情况下，编译器可以根据方法的返回类型推断变量的类型。

如下.从返回类型推断String类型
var name = getName();
String getName(){
    return "zhangsan";
}
使用局部变量类型

顾名思义，局部变量类型推断功能仅适用于局部变量。 它不能用于定义实例或类变量，也不能用于方法参数或返回类型。 但是，您可以在类和增强型循环中使用var，可以从迭代器中推断出类型，如清单4所示。

如下.在循环中使用var
for(var book : books){}
for(int i = 0 ; i < 10 ; i++){}

使用这种类型的最明显的原因是为了减少代码中的冗长。


局部变量类型的问题

1. var掩盖了类型

你已经看到了var如何提高代码的可读性，但是从另一方面来看，它也可以掩盖它。 看看下面的示例，我们必须猜测返回类型。 让读码者猜测发生了什么的代码是难以维护的。
var result = searchService.getAfsService();

2. var不能与lambda一起使用

与lambda表达式一起使用时，类型推断效果不佳，主要原因是编译器缺少类型信息。 如下示例中的lambda表达式不会被编译。如下示例中类型信息不足
Function<String,String> quotify = m -> "'"+message+"'";
var quotify = m -> "'" + message + "'";
在上面示例中，编译器的右边表达式中没有足够的类型信息来推断变量类型。 Lambda语句必须始终声明一个显式类型。

3. var不会与菱形操作符混在一起

与菱形操作符一起使用时，类型推断也不能很好地工作。 如下示例使用带有var的菱形运算符
var books = new ArrayList<>();

books的ArrayList的参数类型是什么呢？你可能明白你是希望ArrayList存储一个书的列表，但是编译器不能推断出来。反之，编译器会做的唯一它能做的事情，就是推断出来这是一个参数是Object类型ArrayList：ArrayList<Object>()。

另外一种方法就是在右端表达式中的菱形运算符中定义具体类型。然后你可以让编译器从而推断出来变量的类型，就像如下示例中写的一样。或者使用另外一种方式，即你必须明确地以传统方式声明变量：List<Book> books。事实上，你可能更喜欢这种方式，因为它能让你定义一个抽象类型，并对List接口编程：

如下， 定义出具体类型
var books = new ArrayList<Book>();

#### JEP 296: 将 JDK 的多个代码仓库合并到一个储存库中
为了简化开发流程，将jdk的数个代码仓库汇集到一个代码仓库中.
多年来，JDK的完整代码库已被分解成多个代码仓库。在JDK 9中有八个仓库：root，corba，hotspot，jaxp，jaxws，jdk，langtools和nashorn。
虽然这种多仓库模式提供了一些优点，但它也有许多缺点，并且在源代码管理操作方面做得不好。特别是，不可能跨越相互依赖的变更集的仓库执行原子提交。
为了解决上面这些问题，已经开发了一个综合仓库的原型。原型可在：

    仓库： http://hg.openjdk.java.net/jdk10/consol-proto/

一些用于创建原型的支持转换脚本附加为unify.zip。

在原型仓库中，八个存储库已经使用自动转换脚本合并到一个仓库中，该脚本在每个文件级别上保留了历史记录，并且在用于标记JDK的一些变更。变更集注释和创建日期也被保留。

原型有另一个代码重组的水平。在合并后的仓库中，Java模块的代码通常组合在单个顶级src目录下。例如，今天在JDK综合仓库中就有基于模块的目录

$ROOT/jdk/src/java.base
...
$ROOT/langtools/src/java.compiler
...

在综合仓库中，代码组织形式如下：

$ROOT/src/java.base
$ROOT/src/java.compiler
...

因此，在代码仓库的根目录中，合并和src目录组合之后，将保留模块中源文件的相对路径。

测试目录组织形式发生如下变更：

从

$ROOT/jdk/test/Foo.java
$ROOT/langtools/test/Bar.java

转为

$ROOT/test/jdk/Foo.java
$ROOT/test/langtools/Bar.java

由于目前在做的仅仅是一个原型，并不是所有部分都完全完成，并且在一些地方需要调整兼容性和适当性。 HotSpot C / C ++源代码与模块化Java代码一起被移至共享src目录。

回归测试将与原型的当前状态一起运行，但jtreg配置文件的进一步整合是可能的，并且可能在将来完成。

#### JEP 304: 垃圾收集器接口。通过引入一个干净的垃圾收集器（GC）接口，改善不同垃圾收集器的源码隔离性。
在当前的JDK结构中，组成垃圾收集器(GC)实现的组件分散在代码库的各个部分。尽管这些惯例对于使用GC计划的JDK开发者比较熟悉，但对新的开发人员来说，对于特定GC的源代码，或者创建一个新的GC常常会感到困惑。更重要的是，随着Java modules的出现，我们希望在构建过程中排除不需要的GC，但是GC接口的当前横切结构排除了这种增强。

JEP 304被设计为解决此问题的方案，并建议整合并清理GC接口，以便更容易地实现新的GC，并更好地维护现有的GC。本建议完成后，GC执行将负责提供以下内容:

    heap，CollectedHeap的子类

    barrier set，BarrierSet的子类，它实现了运行时的各种障碍

    一个CollectorPolicy的实现

    GCInterpreterSupport的实现，它实现了解释器的GC的各种障碍(使用汇编指令)

    GCC1Support的实现，它为C1编译器实现了GC的各种障碍

    GCC2Support的实现，它为C2编译器实现了GC的各种障碍

    最终GC特定参数的初始化

    设置MemoryService、相关的内存池、内存管理器等。



#### JEP 307: 向 G1 引入并行 Full GC
随着JDK 9的发布，Garbage-First(G1)GC取代了Parallel Collector作为默认GC。为了减少JDK 9之外的JDK版本中垃圾收集的影响，G1收集器将被并行化(以匹配并行收集器的特征)。虽然目前还没有关于这个并行化的实现细节的信息，但是可以在JEP 307规范中找到关于此更改的更多细节。
大家如果接触过 Java 性能调优工作，应该会知道，调优的最终目标是通过参数设置来达到快速、低延时的内存垃圾回收以提高应用吞吐量，尽可能的避免因内存回收不及时而触发的完整 GC（Full GC 会带来应用出现卡顿）。

G1 垃圾回收器是 Java 9 中 Hotspot 的默认垃圾回收器，是以一种低延时的垃圾回收器来设计的，旨在避免进行 Full GC，但是当并发收集无法快速回收内存时，会触发垃圾回收器回退进行 Full GC。之前 Java 版本中的 G1 垃圾回收器执行 GC 时采用的是基于单线程标记扫描压缩算法（mark-sweep-compact）。为了最大限度地减少 Full GC 造成的应用停顿的影响，Java 10 中将为 G1 引入多线程并行 GC，同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量。

Java 10 中采用并行化 mark-sweep-compact 算法，并使用与年轻代回收和混合回收相同数量的线程。具体并行 GC 线程数量可以通过：-XX：ParallelGCThreads 参数来调节，但这也会影响用于年轻代和混合收集的工作线程数。

#### JEP 310: 应用类数据共享。为改善启动和占用空间，在现有的类数据共享（“CDS”）功能上再次拓展，以允许应用类放置在共享存档中
此特性的用途是提高运行间和多个运行相同代码的JVM启动时间，同时减少内存占用量。 这通过在JVM之间共享关于类的元数据来实现。 JVM的第一次运行收集并归档有关它所加载的类的数据。 然后它将数据文件提供给其他JVM以及该JVM的后续运行，从而节省JVM初始化过程中的时间和资源。 类数据共享实际上已经有一段时间了，但仅限于系统类。 现在这个功能已经扩展到包含所有的应用程序类。

在 Java 5 中就已经引入了类数据共享机制 (Class Data Sharing，简称 CDS)，允许将一组类预处理为共享归档文件，以便在运行时能够进行内存映射以减少 Java 程序的启动时间，当多个 Java 虚拟机（JVM）共享相同的归档文件时，还可以减少动态内存的占用量，同时减少多个虚拟机在同一个物理或虚拟的机器上运行时的资源占用。简单来说，Java 安装程序会把 rt.jar 中的核心类提前转化成内部表示，转储到一个共享存档（shared archive）中。多个 Java 进程（或者说 JVM 实例）可以共享这部分数据。为改善启动和占用空间，Java 10 在现有的 CDS 功能基础上再次拓展，以允许应用类放置在共享存档中。
CDS 特性在原来的 bootstrap 类基础之上，扩展加入了应用类的 CDS (Application Class-Data Sharing) 支持。
其原理为：在启动时记录加载类的过程，写入到文本文件中，再次启动时直接读取此启动文本并加载。设想如果应用环境没有大的变化，启动速度就会得到提升。
可以想像为类似于操作系统的休眠过程，合上电脑时把当前应用环境写入磁盘，再次使用时就可以快速恢复环境。
对大型企业应用程序的内存使用情况的分析表明，此类应用程序通常会将数以万计的类加载到应用程序类加载器中，如果能够将 AppCDS 应用于这些应用，将为每个 JVM 进程节省数十乃至数百兆字节的内存。另外对于云平台上的微服务分析表明，许多服务器在启动时会加载数千个应用程序类，AppCDS 可以让这些服务快速启动并改善整个系统响应时间。

#### JEP 312: 线程局部管控。允许停止单个线程，而不是只能启用或停止所有线程
这是在 JVM 内部相当低级别的更改，在已有的 Java 版本中，JVM 线程只能全部启用或者停止，没法做到对单独某个线程的操作。为了能够对单独的某个线程进行操作，Java 10 中线程管控引入 JVM 安全点的概念，将允许在不运行全局 JVM 安全点的情况下实现线程回调，由线程本身或者 JVM 线程来执行，同时保持线程处于阻塞状态，这种方式使得停止单个线程变成可能，而不是只能启用或停止所有线程。通过这种方式显著地提高了现有 JVM 功能的性能开销，并且改变了到达 JVM 全局安全点的现有时间语义。

增加的参数为：-XX:ThreadLocalHandshakes (默认为开启)，将允许用户在支持的平台上选择安全点。

#### JEP 313: 移除 Native-Header Generation Tool (javah)
自 Java 9 以来便开始了一些对 JDK 的调整，用户每次调用 javah 工具时会被警告该工具在未来的版本中将会执行的删除操作。当编译 JNI 代码时，已不再需要单独的 Native-Header 工具来生成头文件，因为这可以通过 Java 8（JDK-7150368）中添加的 javac 来完成。在未来的某一时刻，JNI 将会被 Panama 项目的结果取代，但是何时发生还没有具体时间表。

#### JEP 314: 额外的 Unicode 语言标签扩展。包括：cu (货币类型)、fw (每周第一天为星期几)、rg (区域覆盖)、tz (时区) 等
增强 java.util.Locale 和相关 API，实现 BCP 47 语言标签中额外的 Unicode 扩展，支持BCP 47语言标记在 Java SE 7 中最初被添加的，支持Unicode区域设置扩展限于日历和数字。这个JEP将在相关的JDK类中实现最新 LDML 规范中指定的扩展。尤其是，货币类型，一周的第一天，区域覆盖和时区等标签现在将被支持。

自 Java 7 开始支持 BCP 47 语言标记以来， JDK 中便增加了与日历和数字相关的 Unicode 区域设置扩展，在 Java 9 中，新增支持 ca 和 nu 两种语言标签扩展。而在 Java 10 中将继续增加 Unicode 语言标签扩展，具体为：增强 java.util.Locale 类及其相关的 API，以更方便的获得所需要的语言地域环境信息。同时在这次升级中还带来了如下扩展支持：

如下.Unicode 扩展表

编码   注释
cu     货币类型
fw     一周的第一天
rg     区域覆盖
tz     时区

如 Java 10 加入的一个方法：

如下. Unicode 语言标签扩展示例
java.time.format.DateTimeFormatter::localizedBy

通过这个方法，可以采用某种数字样式，区域定义或者时区来获得时间信息所需的语言地域本地环境信息。


#### JEP 316: 在备用内存设备上分配堆内存。允许 HotSpot 虚拟机在备用内存设备上分配 Java 对象堆
硬件技术在持续进化，现在可以使用与传统 DRAM 具有相同接口和类似性能特点的非易失性 RAM 。这项 JEP 将使得 JVM 能够使用适用于不同类型的存储机制的堆。
一些操作系统中已经通过文件系统提供了使用非 DRAM 内存的方法。例如：NTFS DAX 模式和 ext4 DAX。这些文件系统中的内存映射文件可绕过页面缓存并提供虚拟内存与设备物理内存的相互映射。与 DRAM 相比，NV-DIMM 可能具有更高的访问延迟，低优先级进程可以为堆使用 NV-DIMM 内存，允许高优先级进程使用更多 DRAM。

要在这样的备用设备上进行堆分配，可以使用堆分配参数 -XX：AllocateHeapAt = ，这个参数将指向文件系统的文件并使用内存映射来达到在备用存储设备上进行堆分配的预期结果。

#### JEP 317: 基于 Java 的 JIT 编译器（试验版本）
Java 10 中开启了基于 Java 的 JIT 编译器 Graal，并将其用作 Linux/x64 平台上的实验性 JIT 编译器开始进行测试和调试工作，另外 Graal 将使用 Java 9 中引入的 JVM 编译器接口（JVMCI）。

Graal 是一个以 Java 为主要编程语言、面向 Java bytecode 的编译器。与用 C++实现的 C1 及 C2 相比，它的模块化更加明显，也更加容易维护。Graal 既可以作为动态编译器，在运行时编译热点方法；亦可以作为静态编译器，实现 AOT 编译。在 Java 10 中，Graal 作为试验性 JIT 编译器一同发布（JEP 317）。将 Graal 编译器研究项目引入到 Java 中，或许能够为 JVM 性能与当前 C++ 所写版本匹敌（或有幸超越）提供基础。

Java 10 中默认情况下 HotSpot 仍使用的是 C2 编译器，要启用 Graal 作为 JIT 编译器，请在 Java 命令行上使用以下参数：

如下. 启用 Graal 为 JIT 编译器示例

1

-XX：+ UnlockExperimentalVMOptions -XX：+ UseJVMCICompiler

#### JEP 319: 根证书。开源 Java SE Root CA 程序中的根证书
自 Java 9 起在 keytool 中加入参数 -cacerts，可以查看当前 JDK 管理的根证书。而 Java 9 中 cacerts 目录为空，这样就会给开发者带来很多不便。从 Java 10 开始，将会在 JDK 中提供一套默认的 CA 根证书。

作为 JDK 一部分的 cacerts 密钥库旨在包含一组能够用于在各种安全协议的证书链中建立信任的根证书。但是，JDK 源代码中的 cacerts 密钥库至目前为止一直是空的。因此，在 JDK 构建中，默认情况下，关键安全组件（如 TLS）是不起作用的。要解决此问题，用户必须使用一组根证书配置和 cacerts 密钥库下的 CA 根证书。

#### JEP 322: 基于时间的版本发布模式。“Feature releases” 版本将包含新特性，“Update releases” 版本仅修复 Bug
虽然 JEP 223中引入的版本字符串方案较以往有了显著的改进。但是，该方案并不适合以后严格按照六个月的节奏来发布 Java 新版本的这种情况。

按照 JEP 223 的语义中，每个基于 JDK 构建或使用组件的开发者（包括 JDK 的发布者）都必须提前敲定版本号，然后切换过去。开发人员则必须在代码中修改检查版本号的相关代码，这对所有参与者来说都很尴尬和混乱。

Java 10 中将重新编写之前 JDK 版本中引入的版本号方案，将使用基于时间模型定义的版本号格式来定义新版本。保留与 JEP 223 版本字符串方案的兼容性，同时也允许除当前模型以外的基于时间的发布模型。使开发人员或终端用户能够轻松找出版本的发布时间，以便开发人员能够判断是否将其升级到具有最新安全修补程序或可能的附加功能的新版本。

Oracle Java 平台组的首席架构师 Mark Reinhold 在博客上介绍了有关 Java 未来版本的一些想法（你能接受 Java 9 的下一个版本是 Java 18.3 吗？）。他提到，Java 计划按照时间来发布，每半年一个版本，而不是像之前那样按照重要特性来确定大版本，如果某个大的特性因故延期，这个版本可能一拖再拖。

当时，Mark 也提出来一种基于时间命名版本号的机制，比如下一个将于 2018 年 3 月发布的版本，就是 18.3，再下一个版本是 18.9，以后版本依此类推。

不过经过讨论，考虑和之前版本号的兼容等问题，最终选择的命名机制是：

$FEATURE.$INTERIM.$UPDATE.$PATCH

$FEATURE，每次版本发布加 1，不考虑具体的版本内容。2018 年 3 月的版本是 JDK 10，9 月的版本是 JDK 11，依此类推。

$INTERIM，中间版本号，在大版本中间发布的，包含问题修复和增强的版本，不会引入非兼容性修改。
